;-*- Package: (cl-user) -*-;;; A random walk, now with state aggregation, and larger transitions, eg, 1000 states with;;; steps that jump to one of the 100 states to the right or the 100 to the left.;;; This version is for n-step TD methods implemented in the forward view with a little delay;;; file names are number of walks, states, (max)jump, groups (m)(defvar n)                              ; the n of nstep(defparameter m 10)                     ; the number of parameters/groups(defvar group-size)(defparameter NN 1000)                  ; the number of nonterminal states(defparameter max-jump 100)(defvar theta)(defvar alpha)                          ; learning-rate parameter(defvar standard-walks nil)             ; list of standard walks(defvar right-outcome 1.0)(defvar left-outcome -1.0)(defvar initial-V 0.0)(defvar Rstore)(defvar Sstore)(defvar vpi) (defvar d)        (defun setup (num-runs num-walks)  "sets up the problem variables"  (setq Rstore (make-array 10000))  (setq Sstore (make-array 10000))  (setq standard-walks (standard-walks num-runs num-walks NN max-jump))  (length standard-walks)  (setq d (make-array NN :initial-element 0))  (compute-d NN max-jump 2000)  (setq vpi (make-array NN :initial-element 0))  (dp NN max-jump 2000)  (length standard-walks))(defun init ()  "initializes the agent"  (setq theta (make-array m))  (setq group-size (/ nn m))  (check-type group-size integer)  (loop for i below m do (setf (aref theta i) initial-V)))(defun group (s) (floor s group-size))(defun vh (s) (aref theta (group s)))(defun learn (s target)  (let ((g (group s)))    (incf (aref theta g) (* alpha (- target (aref theta g))))))(defun process-walk-nstep (walk)  (let (next capT G)    (destructuring-bind (outcome states) walk      (tagbody       (setf (aref Sstore 0) (pop states))       (loop for tt from 0 to (- n 2) do         (setf (aref Sstore (+ tt 1)) (pop states))         (setf (aref Rstore (+ tt 1))               (if (aref Sstore (+ tt 1)) 0 outcome))         (when (null (aref Sstore (+ tt 1)))           (setq capT (+ tt 1))           (setq next 0)           (go last-loop)))       (loop for tt from 0 do         (setf (aref Sstore (+ tt n)) (pop states))         (setf (aref Rstore (+ tt n))               (if (aref Sstore (+ tt n)) 0 outcome))         (setq G (loop for k from 0 to (- n 1) sum (aref Rstore (+ tt k 1))))         (if (aref Sstore (+ tt n)) (incf G (vh (aref Sstore (+ tt n)))))         (learn (aref Sstore tt) G)         (when (null (aref Sstore (+ tt n)))           (setq capT (+ tt n))           (setq next (+ tt 1))           (go last-loop)))       last-loop       (loop for tt from next to (- capT 1) do         (setq G (loop for k from (+ tt 1) to capT sum (aref Rstore k)))         (learn (aref Sstore tt) G))))))(defun standard-walks (num-sets-of-walks num-walks NN max-jump)  (loop repeat num-sets-of-walks         with random-state = (ut::copy-of-standard-random-state)        collect (loop repeat num-walks                      collect (random-walk NN max-jump random-state))))(defun random-walk (n max-jump &optional (random-state *random-state*))  (loop with start-state = (truncate (/ (- n 1) 2))    for jump-maybe0 = (- (random (* 2 max-jump) random-state) max-jump)    for jump = (if (= 0 jump-maybe0) max-jump jump-maybe0)    for x = start-state then (+ x jump)    while (AND (>= x 0) (< x n))    collect x into xs    finally (return (list (if (< x 0) left-outcome right-outcome) xs))))(defun dp (n max-jump num-sweeps)  (loop repeat num-sweeps do    (loop for s below n do       (setf (aref vpi s)            (/ (loop for sp from (- s max-jump) below s                     for spp from (+ s 1)                 sum (if (< sp 0) -1 (aref vpi sp))                 sum (if (>= spp n) 1 (aref vpi spp)))               (float (* 2 max-jump)))))))(defun compute-d (n max-jump num-sweeps)  (loop with start-state = (truncate (/ (- n 1) 2))    repeat num-sweeps do    (loop for s below n do      (setf (aref d s)            (+ (if (= s start-state) 1 0)               (/ (loop for sp from (- s max-jump) below s                        for spp from (+ s 1)                    sum (if (< sp 0) 0 (aref d sp))                    sum (if (>= spp n) 0 (aref d spp)))                  (float (* 2 max-jump))))))))(defun residual-error ()  "Returns the residual RMSE between the current and correct predictions"  (sqrt (loop for s below NN          sum (* (aref d s)                  (square (- (vh s)                             (aref vpi s)))))))(defun learning-curve-nstep (alpha-arg n-arg num-walks)  (when (> num-walks (length (first standard-walks))) (error "not enough walks available"))  (setq alpha alpha-arg)  (setq n n-arg)  (multi-mean    (loop for walk-set in standard-walks         do (init)         collect (cons (residual-error)                       (loop for walk in walk-set                             for walk-num below num-walks                             do (process-walk-nstep walk)                             collect (residual-error))))))(defun nstep (num-walks)  "summary results as fn of alpha, for various n"  (graph (loop for nstep = 1 then (* nstep 2) while (< nstep 1000) collect           (cons (progn (init) (list 0 (residual-error)))                 (loop for alog from -5 to 0 by 0.1                   for alpha = (exp alog)                   for error = (mean (rest (learning-curve-nstep alpha nstep num-walks)))                   while (< error 10)                   collect (list alpha error))))         nil "parameter study")  (sleep 0.5)  (y-tick-marks .15 .20 .25 .3 .35 .4 .45 .5 .55)  (x-tick-marks 0 .2 .4 .6 .8 1)  (y-graph-limits .15 .55)  (x-graph-limits 0 1))    #|(setup 1 100000)(graph+ (learning-curve-nstep 0.0002 1 100000) nil "learning curve")(nstep 10)(graph (l vpi) nil "values")(progn (subtract-from-graph nil "values")       (graph+ (loop for s below NN collect (vh s)) :blue "values"))(y-graph-limits 1.9 3.7)(graph+ (loop for ds across d collect (- (/ ds .57) 1)) :gray "values")(y-tick-marks 2 2.5 3 3.5)(y-tick-marks -1 0 1)|#