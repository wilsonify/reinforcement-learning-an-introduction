;-*- Package: (cl-user) -*-;;; A random walk, now with function approximation, and larger transitions, eg, 1000 states with;;; steps that jump to one of the 100 states to the right or the 100 to the left.;;; This version is for n-step TD methods implemented in the forward view with a little delay;;; file names are number of walks, states, (max)jump, groups (m);;; (defvar n)                              ; the n of nstep(defvar m 100)                          ; the number of parameters/groups(defvar group-size)(defvar NN 1000)                        ; the number of nonterminal states(defvar max-jump 100)(defvar theta)(defvar alpha)                          ; learning-rate parameter(defvar standard-walks nil)             ; list of standard walks(defvar right-outcome 1.0)(defvar left-outcome -1.0)(defvar initial-v 0.0)(defvar Rstore)(defvar Sstore)(defvar vpi) (defvar d)   (defvar iht)(defvar num-tilings)(defvar fa :ag) (defvar mem-size 1200)(defvar tiles)(defvar num-weights)(defvar phi)(defun setup (num-runs num-walks)  "sets up the problem variables"  (setq Rstore (make-array 10000))  (setq Sstore (make-array 10000))  (setq standard-walks (standard-walks num-runs num-walks NN max-jump))  (compute-d NN max-jump 2000)  (dp NN max-jump 2000)  (length standard-walks))(defun init ()  "initializes the agent"  (setq num-weights (ecase fa ((:ag :fb :po) m) (:tc mem-size)))  (setq theta (make-array num-weights :initial-element initial-v))  (setq group-size (/ nn m))  (case fa ((:ag :tc) (check-type group-size integer))))(defun terminalp (s)  (null s))(defun setup-tiles (nn m skip)  (setq iht (make-iht mem-size))  (setq tiles (make-array nn))  (setq num-tilings (/ nn m skip))  (loop for s below nn do    (setf (aref tiles s)          (tiles iht num-tilings (list (* m (/ s (- (float nn) 1)))))))  (values))  ;(setq alpha (/ alpha num-tilings)))(defun setup-phi-poly (degree+1)  (setq phi (make-array (list nn degree+1) :initial-element 0))  (loop for i below degree+1    do (loop for s from 0 below nn          do (setf (aref phi s i)                   (expt (/ s (float (- nn 1))) i))))  (values))  ;  (setq a (/ alpha degree+1)))(defun setup-phi-fb (degree+1)  (setq phi (make-array (list nn degree+1) :initial-element 0))  (loop for i below degree+1    do (loop for s from 0 below nn          do (setf (aref phi s i)                   (cos (* 3.1415926 (/ s (float (- nn 1))) i)))))  (values))  ;  (setq a (/ alpha degree+1)))(defun group (s) (floor s group-size))(defun vh (s)   (ecase fa    (:ag (aref theta (group s)))    (:tc (loop for tile in (aref tiles s) sum (aref theta tile)))    ((:fb :po) (loop for i below m sum (* (aref theta i) (aref phi s i))))))(defun learn (s target)  (ecase fa    (:ag (let ((g (group s)))           (incf (aref theta g) (* alpha (- target (aref theta g))))))    (:tc (loop with alpha-error = (* alpha (- target (vh s)))           for i in (aref tiles s) do (incf (aref theta i) alpha-error)))    ((:fb :po)     (loop with alpha-error = (* alpha (- target (vh s)))       for i below m do (incf (aref theta i) (* alpha-error (aref phi s i)))))))           (defun episode (walk)  (destructuring-bind (outcome states) walk    (setf (aref Sstore 0) (pop states))    (loop with capT = 10000000000 and G      for tt from 0      for tau = (+ tt (- n) 1)      for tau+n = (+ tau n) do      (when (< tt capT)        (let* ((Sprime (pop states))               (R (if Sprime 0 outcome)))          (setf (aref Rstore (+ tt 1)) R)          (if (terminalp Sprime)            (setq capT (+ tt 1))            (setf (aref Sstore (+ tt 1)) Sprime))))      (when (>= tau 0)        (setq G (loop for i from (1+ tau) to (min tau+n capT) sum (aref Rstore i)))        (when (< tau+n capT) (incf G (vh (aref Sstore tau+n))))        (learn (aref Sstore tau) G))      until (= tau (- capT 1)))))(defun process-walk (walk)  (let (next capT G)    (destructuring-bind (outcome states) walk      (tagbody       (setf (aref Sstore 0) (pop states))       (loop for tt from 0 to (- n 2) do         (setf (aref Sstore (+ tt 1)) (pop states))         (setf (aref Rstore (+ tt 1))               (if (aref Sstore (+ tt 1)) 0 outcome))         (when (null (aref Sstore (+ tt 1)))           (setq capT (+ tt 1))           (setq next 0)           (go last-loop)))       (loop for tt from 0 do         (setf (aref Sstore (+ tt n)) (pop states))         (setf (aref Rstore (+ tt n))               (if (aref Sstore (+ tt n)) 0 outcome))         (setq G (loop for k from 0 to (- n 1) sum (aref Rstore (+ tt k 1))))         (if (aref Sstore (+ tt n)) (incf G (vh (aref Sstore (+ tt n)))))         (learn (aref Sstore tt) G)         (when (null (aref Sstore (+ tt n)))           (setq capT (+ tt n))           (setq next (+ tt 1))           (go last-loop)))       last-loop       (loop for tt from next to (- capT 1) do         (setq G (loop for k from (+ tt 1) to capT sum (aref Rstore k)))         (learn (aref Sstore tt) G))))))(defun standard-walks (num-sets-of-walks num-walks NN max-jump)  (loop repeat num-sets-of-walks         with random-state = (ut::copy-of-standard-random-state)        collect (loop repeat num-walks                      collect (random-walk NN max-jump random-state))))(defun random-walk (n max-jump &optional (random-state *random-state*))  (loop with start-state = (truncate (/ (- n 1) 2))    for jump-maybe0 = (- (random (* 2 max-jump) random-state) max-jump)    for jump = (if (= 0 jump-maybe0) max-jump jump-maybe0)    for x = start-state then (+ x jump)    while (AND (>= x 0) (< x n))    collect x into xs    finally (return (list (if (< x 0) left-outcome right-outcome) xs))))(defun dp (n max-jump num-sweeps)  (setq vpi (make-array n :initial-element 0.0))  (loop repeat num-sweeps do    (loop for s below n do       (setf (aref vpi s)            (/ (loop for sp from (- s max-jump) below s                     for spp from (+ s 1)                 sum (if (< sp 0) -1 (aref vpi sp))                 sum (if (>= spp n) 1 (aref vpi spp)))               (float (* 2 max-jump)))))))(defun compute-d (n max-jump num-sweeps)  (setq d (make-array n :initial-element 0.0))  (loop with start-state = (truncate (/ (- n 1) 2))    repeat num-sweeps do    (loop for s below n do      (setf (aref d s)            (+ (if (= s start-state) 1 0)               (/ (loop for sp from (- s max-jump) below s                        for spp from (+ s 1)                    sum (if (< sp 0) 0 (aref d sp))                    sum (if (>= spp n) 0 (aref d spp)))                  (float (* 2 max-jump)))))))  (loop with sumd = (loop for s below n sum (aref d s))    for s below n    do (setf (aref d s) (/ (aref d s) sumd))    finally (return sumd)))(defun residual-error ()  "Returns the residual RMSE between the current and correct predictions"  (sqrt (loop for s below NN          sum (* (aref d s)                  (square (- (vh s)                             (aref vpi s)))))))(defun residual-naive-error ()  "Returns the residual RMSE between the current and correct predictions"  (rmse 0 (loop for s below NN                for vpi-s across vpi                collect (- (vh s) vpi-s))))(defun learning-curve (fa-arg m-arg skip-arg alpha-arg n-arg num-runs num-walks)  (when (> num-walks (length (first standard-walks))) (error "not enough walks available"))  (when (> num-runs (length standard-walks)) (error "not enough walk sets available"))  (setq fa fa-arg)  (setq m m-arg)  (case fa (:tc (setup-tiles nn m skip-arg)) (:po (setup-phi-poly m)) (:fb (setup-phi-fb m)))  (setq n n-arg)  (multi-mean    (loop for walk-set in standard-walks repeat num-runs do     (init)     (setq alpha alpha-arg)     collect (cons (residual-error)                   (nconc (loop for walk in walk-set                            for walk-num below num-walks                            do (process-walk walk)                            collect (residual-naive-error))#|                          (loop initially (setq alpha (/ alpha-arg 10.0))                            for walk in (nthcdr num-walks walk-set)                            for walk-num below (* 2 num-walks)                            do (episode walk)                            collect (residual-error))                          (loop initially (setq alpha (/ alpha-arg 50.0))                            for walk in (nthcdr (* 3 num-walks) walk-set)                            for walk-num below (* 7 num-walks)                            do (episode walk)                            collect (residual-error))|#                          )))))(defun nstep (num-runs num-walks)  "summary results as fn of alpha, for various n"  (graph (loop for nstep = 1 then (* nstep 2) while (< nstep 1000) collect           (loop for alog from -5 to 0 by 0.1                   for alpha = (exp alog)                   for error = (mean (rest (learning-curve :ag m nil alpha nstep num-runs num-walks)))                   while (< error 10)                   collect (list alpha error)))         nil "parameter study")  (sleep 0.5)  (y-tick-marks .15 .20 .25 .3 .35 .4 .45 .5 .55)  (x-tick-marks 0 .2 .4 .6 .8 1)  (y-graph-limits .25 .55)  (x-graph-limits 0 1))    #|(setup 30 100000)(graph+ (learning-curve 0.0002 1000 30 4000) nil "learning curve")    m=5 (red) m=10 (green)(graph+ (learning-curve 0.0002 1000 30 10000) nil "learning curve")   m=20 (blue)(graph+ (learning-curve 0.001 1000 30 10000) nil "learning curve")   m=100 (black)Above is lc-mc-ag.pdf(subtract-from-graph)(clear-graph)(graph+ (learning-curve  :tc 5 10 0.00001 1000 30 4000) "learning curve")(graph (learning-curve  :po 5 nil 0.0001 1000 30 4000) "learning curve")      red      lc-mc-po.pdf(graph+ (learning-curve :po 2 nil 0.0002 1000 30 4000) "learning curve")      green(graph+ (learning-curve :po 10 nil 0.00005 1000 30 4000) "learning curve")    blue(graph (learning-curve  :fb 5 nil 0.0001 1000 30 4000) "learning curve")       red      lc-mc-fb.pdf(graph+ (learning-curve :fb 2 nil 0.0001 1000 30 4000) "learning curve")      green(graph+ (learning-curve :fb 10 nil 0.00005 1000 30 4000) "learning curve")    blue(graph+ (learning-curve :fb 20 nil 0.00005 1000 30 4000) "learning curve")    black(loop for mm in '(5 10 20 40 100 200) do     (graph+ (learning-curve :ag mm (* mm 0.00001) 1000 30 10000) "learning curve")) lc-mc-ag-2.pdf(loop for mm in '(5 10 20 40 100 200) do     (graph+ (learning-curve :tc mm 5 (* mm .00001) 1000 30 10000) "learning curve"))    lc-mc-tc.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :ag mm nil (* mm 0.00002) 1000 10 5000) "learning curve")) lc-mc-ag-5000.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :tc mm 10 (* mm .00002) 1000 10 5000) "learning curve tc"))  lc-mc-tc-5000.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :ag mm nil (* mm 0.00004) 1000 30 2500) "learning curve")) lc-mc-ag-2500.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :tc mm 10 (* mm .00004) 1000 30 2500) "learning curve tc"))  lc-mc-tc-2500.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :ag mm nil (* mm 0.0001) 1000 30 1000) "learning curve")) lc-mc-1000.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :tc mm 10 (* mm .0001) 1000 30 1000) "learning curve tc")) (loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :ag mm nil (* mm 0.0001) 1000 30 1000) "learning curve")) lc-mc-1000+4000.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :tc mm 10 (* mm .0001) 1000 30 1000) "learning curve tc"))(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :ag mm nil (* mm 0.0001) 1000 30 1000) "learning curve")) lc-mc-1000+1000+2000.pdf(loop for mm in '(5 10 20 40) do     (graph+ (learning-curve :tc mm 10 (* mm .0001) 1000 30 1000) "learning curve tc"))(loop for mm in '(5 10 20) do     (graph+ (learning-curve :ag mm nil (* mm 0.0001) 1000 30 1000) "learning curve")) lc-mc-1000+2000+7000.pdf(loop for mm in '(5 10 20) do     (graph+ (learning-curve :tc mm 10 (* mm .0001) 1000 30 1000) "learning curve tc"))(grid-graph)(progn(graph  (learning-curve :ag 5 nil 0.0001 1000 30 10000) "learning curve")   red        lc-mc-10000.pdf(graph+ (learning-curve :tc 5  4  0.000002 1000 30 10000) "learning curve") green(graph+ (learning-curve :po 6 nil 0.00012 1000 30 10000) "learning curve")  blue(graph+ (learning-curve :fb 6 nil 0.00004 1000 30 10000) "learning curve")) black(graph  (learning-curve :ag 5 nil 0.0001 1000 30 5000) "learning curve5000")   red     lc-mc-5000.pdf(graph+ (learning-curve :tc 5 4   0.000002 1000 30 5000) "learning curve5000") green(graph+ (learning-curve :po 6 nil 0.00012 1000 30 5000) "learning curve5000")  blue(graph+ (learning-curve :fb 6 nil 0.00004 1000 30 5000) "learning curve5000")  black(let ((runs 30))(graph  (learning-curve  :po 6  nil 0.0001 1000 runs 5000) "poly vs fourier");(graph+ (learning-curve :po 6  nil 0.0002 1000 runs 5000) "poly vs fourier");(graph+ (learning-curve :po 6  nil 0.00005 1000 runs 5000) "poly vs fourier")(graph+ (learning-curve  :po 11 nil 0.0001 1000 runs 5000) :pink "poly vs fourier");(graph+ (learning-curve :po 11 nil 0.0002 1000 runs 5000) "poly vs fourier");(graph+ (learning-curve :po 11 nil 0.00005 1000 runs 5000) "poly vs fourier")(graph+ (learning-curve  :po 21 nil 0.0001  1000 runs 5000) :orange "poly vs fourier")(graph+ (learning-curve  :fb 6  nil 0.00004 1000 runs 5000) :green "poly vs fourier")(graph+ (learning-curve  :fb 6  nil 0.00005 1000 runs 5000) :blue "poly vs fourier");(graph+ (learning-curve :fb 6  nil 0.0001  1000 runs 5000) :light-blue "poly vs fourier")(graph+ (learning-curve  :fb 11 nil 0.0001 1000 runs 5000) :green "poly vs fourier")(graph+ (learning-curve  :fb 21 nil 0.00005 1000 runs 5000) :dark-green "poly vs fourier"))(graph-)(graph- :green)(nstep 10)(graph (l vpi) nil "values")(progn (clear-graph "values")       (graph+ (loop for s below NN collect (vh s)) :blue "values"))(y-graph-limits -1 1)(y-graph-limits 1.9 3.7)(y-graph-limits 0 .41)(graph+ (loop for ds across d collect (- (/ ds .57) 1)) :gray "values")(y-tick-marks 2 2.5 3 3.5)(y-tick-marks -1 0 1)(progn (y-tick-marks 0 .1 .2 .3 .4)       (y-graph-limits 0 .41)       (grid-graph))|#